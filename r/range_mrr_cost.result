set optimizer_switch='mrr=on,mrr_cost_based=on';
drop table if exists t1, t2, t3;
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
Warnings:
Warning	3090	Changing sql mode 'NO_AUTO_CREATE_USER' is deprecated. It will be removed in a future release.
create table t1(
Satellite		varchar(25)	not null,
SensorMode		varchar(25)	not null,
FullImageCornersUpperLeftLongitude	double	not null,
FullImageCornersUpperRightLongitude	double	not null,
FullImageCornersUpperRightLatitude	double	not null,
FullImageCornersLowerRightLatitude	double	not null,
index two (Satellite, SensorMode, FullImageCornersUpperLeftLongitude, FullImageCornersUpperRightLongitude, FullImageCornersUpperRightLatitude, FullImageCornersLowerRightLatitude));
insert into t1 values("OV-3","PAN1",91,-92,40,50);
insert into t1 values("OV-4","PAN1",91,-92,40,50);
select * from t1 where t1.Satellite = "OV-3" and t1.SensorMode = "PAN1" and t1.FullImageCornersUpperLeftLongitude > -90.000000 and t1.FullImageCornersUpperRightLongitude < -82.000000;
Satellite	SensorMode	FullImageCornersUpperLeftLongitude	FullImageCornersUpperRightLongitude	FullImageCornersUpperRightLatitude	FullImageCornersLowerRightLatitude
OV-3	PAN1	91	-92	40	50
drop table t1;
create table t1 ( aString char(100) not null default "", key aString (aString(10)) );
insert t1 (aString) values ( "believe in myself" ), ( "believe" ), ("baaa" ), ( "believe in love");
select * from t1 where aString < "believe in myself" order by aString;
aString
baaa
believe
believe in love
select * from t1 where aString > "believe in love" order by aString;
aString
believe in myself
alter table t1 drop key aString;
select * from t1 where aString < "believe in myself" order by aString;
aString
baaa
believe
believe in love
select * from t1 where aString > "believe in love" order by aString;
aString
believe in myself
drop table t1;
CREATE TABLE t1 (
a int(11) default NULL,
b int(11) default NULL,
KEY a (a),
KEY b (b)
) ENGINE=sequoiadb;
INSERT INTO t1 VALUES
(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,2),(10,2),
(13,2),(14,2),(15,2),(16,2),(17,3),(17,3),(16,3),(17,3),(19,3),(20,3),
(21,4),(22,5),(23,5),(24,5),(25,5),(26,5),(30,5),(31,5),(32,5),(33,5),
(33,5),(33,5),(33,5),(33,5),(34,5),(35,5);
SELECT * FROM t1 WHERE a IN(1,2) AND b=5;
a	b
DROP TABLE t1;
CREATE TABLE t1 (a int, b int, c int, INDEX (c,a,b));
INSERT INTO t1 VALUES (1,0,0),(1,0,0),(1,0,0);
INSERT INTO t1 VALUES (0,1,0),(0,1,0),(0,1,0);
SELECT COUNT(*) FROM t1 WHERE (c=0 and a=1) or (c=0 and b=1);
COUNT(*)
6
SELECT COUNT(*) FROM t1 WHERE (c=0 and b=1) or (c=0 and a=1);
COUNT(*)
6
DROP TABLE t1;
CREATE TABLE t1 ( a int not null, b int not null, INDEX ab(a,b) );
INSERT INTO t1 VALUES (47,1), (70,1), (15,1), (15, 4);
SELECT * FROM t1
WHERE
(
( b =1 AND a BETWEEN 14 AND 21 ) OR
( b =2 AND a BETWEEN 16 AND 18 ) OR
( b =3 AND a BETWEEN 15 AND 19 ) OR
(a BETWEEN 19 AND 47)
);
a	b
15	1
47	1
DROP TABLE t1;
create  table t1 (id int(10) primary key);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9);
select id from t1 where id in (2,5,9) ;
id
2
5
9
select id from t1 where id=2 or id=5 or id=9 ;
id
2
5
9
drop table t1;
create table t1 ( id1 int not null, id2 int not null, idnull int null, c char(20), primary key (id1,id2));
insert into t1 values (0,1,NULL,"aaa"), (1,1,NULL,"aaa"), (2,1,NULL,"aaa"),
(3,1,NULL,"aaa"), (4,1,NULL,"aaa"), (5,1,NULL,"aaa"),
(6,1,NULL,"aaa"), (7,1,NULL,"aaa"), (8,1,NULL,"aaa"),
(9,1,NULL,"aaa"), (10,1,NULL,"aaa"), (11,1,NULL,"aaa"),
(12,1,NULL,"aaa"), (13,1,NULL,"aaa"), (14,1,NULL,"aaa"),
(15,1,NULL,"aaa"), (16,1,NULL,"aaa"), (17,1,NULL,"aaa"),
(18,1,NULL,"aaa"), (19,1,NULL,"aaa"), (20,1,NULL,"aaa");
select a.id1, b.idnull from t1 as a, t1 as b where a.id2=1 and a.id1=1 and b.id1=a.idnull order by b.id2 desc limit 1;
id1	idnull
drop table t1;
create table t1 (x bigint unsigned not null);
insert into t1(x) values (0xfffffffffffffff0);
insert into t1(x) values (0xfffffffffffffff1);
select * from t1;
x
18446744073709551600
18446744073709551601
select count(*) from t1 where x>0;
count(*)
2
select count(*) from t1 where x=0;
count(*)
0
select count(*) from t1 where x<0;
count(*)
0
select count(*) from t1 where x < -16;
count(*)
0
select count(*) from t1 where x = -16;
count(*)
0
select count(*) from t1 where x > -16;
count(*)
2
select count(*) from t1 where x = 18446744073709551601;
count(*)
1
create table t2 (x bigint not null);
insert into t2(x) values (-16);
insert into t2(x) values (-15);
select * from t2;
x
-16
-15
select count(*) from t2 where x>0;
count(*)
0
select count(*) from t2 where x=0;
count(*)
0
select count(*) from t2 where x<0;
count(*)
2
select count(*) from t2 where x < -16;
count(*)
0
select count(*) from t2 where x = -16;
count(*)
1
select count(*) from t2 where x > -16;
count(*)
1
select count(*) from t2 where x = 18446744073709551601;
count(*)
0
drop table t1,t2;
create table t1 (x bigint unsigned not null primary key) engine=sequoiadb;
insert into t1(x) values (0xfffffffffffffff0);
insert into t1(x) values (0xfffffffffffffff1);
select * from t1;
x
18446744073709551600
18446744073709551601
select count(*) from t1 where x>0;
count(*)
2
select count(*) from t1 where x=0;
count(*)
0
select count(*) from t1 where x<0;
count(*)
0
select count(*) from t1 where x < -16;
count(*)
0
select count(*) from t1 where x = -16;
count(*)
0
select count(*) from t1 where x > -16;
count(*)
2
select count(*) from t1 where x = 18446744073709551601;
count(*)
1
drop table t1;
create table t1 (a bigint unsigned);
create index t1i on t1(a);
insert into t1 select 18446744073709551615;
insert into t1 select 18446744073709551614;
select * from t1 where a <> -1;
a
18446744073709551614
18446744073709551615
select * from t1 where a > -1 or a < -1;
a
18446744073709551614
18446744073709551615
select * from t1 where a > -1;
a
18446744073709551614
18446744073709551615
select * from t1 where a < -1;
a
drop table t1;
CREATE TABLE t1 (
`CLIENT` char(3) character set latin1 collate latin1_bin NOT NULL default '000',
`ARG1` char(3) character set latin1 collate latin1_bin NOT NULL default '',
`ARG2` char(3) character set latin1 collate latin1_bin NOT NULL default '',
`FUNCTION` varchar(10) character set latin1 collate latin1_bin NOT NULL default '',
`FUNCTINT` int(11) NOT NULL default '0',
KEY `VERI_CLNT~2` (`ARG1`)
) ENGINE=sequoiadb DEFAULT CHARSET=latin1;
INSERT INTO t1 VALUES ('000',' 0',' 0','Text 001',0), ('000',' 0',' 1','Text 002',0),
('000',' 1',' 2','Text 003',0), ('000',' 2',' 3','Text 004',0),
('001',' 3',' 0','Text 017',0);
SELECT count(*) FROM t1 WHERE CLIENT='000' AND (ARG1 != ' 1' OR ARG1 != ' 2');
count(*)
4
SELECT count(*) FROM t1 WHERE CLIENT='000' AND (ARG1 != ' 2' OR ARG1 != ' 1');
count(*)
4
drop table t1;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
CREATE TABLE t2 (
pk1 int(11) NOT NULL,
pk2 int(11) NOT NULL,
pk3 int(11) NOT NULL,
pk4 int(11) NOT NULL,
filler char(82),
PRIMARY KEY (pk1,pk2,pk3,pk4)
) DEFAULT CHARSET=latin1;
insert into t2 select 1, A.a+10*B.a, 432, 44, 'fillerZ' from t1 A, t1 B;
INSERT INTO t2 VALUES (2621, 2635, 0, 0,'filler'), (2621, 2635, 1, 0,'filler'),
(2621, 2635, 10, 0,'filler'), (2621, 2635, 11, 0,'filler'),
(2621, 2635, 14, 0,'filler'), (2621, 2635, 1000015, 0,'filler');
SELECT * FROM t2
WHERE ((((pk4 =0) AND (pk1 =2621) AND (pk2 =2635)))
OR ((pk4 =1) AND (((pk1 IN ( 7, 2, 1 ))) OR (pk1 =522)) AND ((pk2 IN ( 0, 2635))))
) AND (pk3 >=1000000);
pk1	pk2	pk3	pk4	filler
2621	2635	1000015	0	filler
drop table t1, t2;
create table t1(a char(2), key(a(1)));
insert into t1 values ('x'), ('xx');
select a from t1 where a > 'x';
a
xx
drop table t1;
CREATE TABLE t1 (
OXID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT '',
OXPARENTID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT 'oxrootid',
OXLEFT int NOT NULL DEFAULT '0',
OXRIGHT int NOT NULL DEFAULT '0',
OXROOTID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT '',
PRIMARY KEY  (OXID),
#KEY OXNID (OXID),
KEY OXLEFT (OXLEFT),
KEY OXRIGHT (OXRIGHT),
KEY OXROOTID (OXROOTID)
) ENGINE=sequoiadb DEFAULT CHARSET=latin1 COLLATE=latin1_german2_ci;
INSERT INTO t1 VALUES
('d8c4177d09f8b11f5.52725521','oxrootid',1,40,'d8c4177d09f8b11f5.52725521'),
('d8c4177d151affab2.81582770','d8c4177d09f8b11f5.52725521',2,3,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d206a333d2.74422679','d8c4177d09f8b11f5.52725521',4,5,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d225791924.30714720','d8c4177d09f8b11f5.52725521',6,7,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d2380fc201.39666693','d8c4177d09f8b11f5.52725521',8,9,
'd8c4177d09f8b11f5.52725521'),
('d8c4177d24ccef970.14957924','d8c4177d09f8b11f5.52725521',10,11,
'd8c4177d09f8b11f5.52725521');
SELECT s.oxid FROM t1 v, t1 s 
WHERE s.oxrootid = 'd8c4177d09f8b11f5.52725521' AND
v.oxrootid ='d8c4177d09f8b11f5.52725521' AND
s.oxleft > v.oxleft AND s.oxleft < v.oxright;
oxid
d8c4177d151affab2.81582770
d8c4177d206a333d2.74422679
d8c4177d225791924.30714720
d8c4177d2380fc201.39666693
d8c4177d24ccef970.14957924
DROP TABLE t1;
create table t1 (
c1  char(10), c2  char(10), c3  char(10), c4  char(10),
c5  char(10), c6  char(10), c7  char(10), c8  char(10),
c9  char(10), c10 char(10), c11 char(10), c12 char(10),
c13 char(10), c14 char(10), c15 char(10), c16 char(10),
index(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12,c13,c14,c15,c16)
);
insert into t1 (c1) values ('1'),('1'),('1'),('1');
select * from t1 where
c1 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4",
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c2 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c3 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c4 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5", 
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c5 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4",
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c6 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4",
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c7 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c8 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c9 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
and c10 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
"abcdefg1", "123456781", "qwertyui1", "asddfg1", 
"abcdefg2", "123456782", "qwertyui2", "asddfg2", 
"abcdefg3", "123456783", "qwertyui3", "asddfg3", 
"abcdefg4", "123456784", "qwertyui4", "asddfg4", 
"abcdefg5", "123456785", "qwertyui5", "asddfg5",
"abcdefg6", "123456786", "qwertyui6", "asddfg6",
"abcdefg7", "123456787", "qwertyui7", "asddfg7",
"abcdefg8", "123456788", "qwertyui8", "asddfg8",
"abcdefg9", "123456789", "qwertyui9", "asddfg9",
"abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
"abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
"abcdefgC", "12345678C", "qwertyuiC", "asddfgC");
c1	c2	c3	c4	c5	c6	c7	c8	c9	c10	c11	c12	c13	c14	c15	c16
Warnings:
Warning	3170	Memory capacity of 8388608 bytes for 'range_optimizer_max_mem_size' exceeded. Range optimization was not done for this query.
drop table t1;
End of 4.1 tests
CREATE TABLE t1 (
#id int(11) NOT NULL auto_increment,
id int(11) NOT NULL,
status varchar(20),
PRIMARY KEY  (id),
KEY (status)
);
INSERT INTO t1 VALUES
(1,'B'), (2,'B'), (3,'B'), (4,'B'), (5,'B'), (6,'B'),
(7,'B'), (8,'B'), (9,'B'), (10,'B'), (11,'B'), (12,'B'),
(13,'B'), (14,'B'), (15,'B'), (16,'B'), (17,'B'), (18,'B'),
(19,'B'), (20,'B'), (21,'B'), (22,'B'), (23,'B'), (24,'B'), 
(25,'A'), (26,'A'), (27,'A'), (28,'A'), (29,'A'), (30,'A'),
(31,'A'), (32,'A'), (33,'A'), (34,'A'), (35,'A'), (36,'A'),
(37,'A'), (38,'A'), (39,'A'), (40,'A'), (41,'A'), (42,'A'),
(43,'A'), (44,'A'), (45,'A'), (46,'A'), (47,'A'), (48,'A'),
(49,'A'), (50,'A'), (51,'A'), (52,'A'), (53,'C'), (54,'C'),
(55,'C'), (56,'C'), (57,'C'), (58,'C'), (59,'C'), (60,'C');
SELECT * FROM t1 WHERE status <> 'A' AND status <> 'B';
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
SELECT * FROM t1 WHERE status NOT IN ('A','B');
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
SELECT * FROM t1 WHERE status NOT BETWEEN 'A' AND 'B';
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
SELECT * FROM t1 WHERE status < 'A' OR status > 'B';
id	status
53	C
54	C
55	C
56	C
57	C
58	C
59	C
60	C
DROP TABLE t1;
CREATE TABLE  t1 (a int, b int, primary key(a,b));
INSERT INTO  t1 VALUES
(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3);
CREATE VIEW v1 as SELECT a,b FROM t1 WHERE b=3;
SELECT a,b FROM t1 WHERE a < 2 and b=3;
a	b
1	3
SELECT a,b FROM v1 WHERE a < 2 and b=3;
a	b
1	3
DROP VIEW v1;
DROP TABLE t1;
CREATE TABLE t1 (name varchar(15) NOT NULL, KEY idx(name));
INSERT INTO t1 VALUES ('Betty'), ('Anna');
SELECT * FROM t1;
name
Betty
Anna
DELETE FROM t1 WHERE name NOT LIKE 'A%a';
SELECT * FROM t1;
name
Anna
DROP TABLE t1;
CREATE TABLE t1 (a int, KEY idx(a));
INSERT INTO t1 VALUES (NULL), (1), (2), (3);
SELECT * FROM t1;
a
NULL
1
2
3
DELETE FROM t1 WHERE NOT(a <=> 2);
SELECT * FROM t1;
a
2
DROP TABLE t1;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, key(a));
insert into t2 select 2*(A.a + 10*(B.a + 10*C.a)) from t1 A, t1 B, t1 C;
set @a="select * from t2 force index (a) where a NOT IN(0";
select count(*) from (select @a:=concat(@a, ',', a) from t2 ) Z;
count(*)
1000
set @a=concat(@a, ')');
insert into t2 values (11),(13),(15);
set @b= concat("explain ", @a);
prepare stmt1 from @a;
execute stmt1;
a
11
13
15
drop table t1, t2;
CREATE TABLE t1 (
id int NOT NULL DEFAULT '0',
b int NOT NULL DEFAULT '0',
c int NOT NULL DEFAULT '0', 
INDEX idx1(b,c), INDEX idx2(c));
INSERT INTO t1(id) VALUES (1), (2), (3), (4), (5), (6), (7), (8);
INSERT INTO t1(b,c) VALUES (3,4), (3,4);
SELECT * FROM t1 WHERE b<=3 AND 3<=c;
id	b	c
0	3	4
0	3	4
SELECT * FROM t1 WHERE 3 BETWEEN b AND c;
id	b	c
0	3	4
0	3	4
SELECT * FROM t1 WHERE 0 < b OR 0 > c;
id	b	c
0	3	4
0	3	4
SELECT * FROM t1 WHERE 0 NOT BETWEEN b AND c;
id	b	c
0	3	4
0	3	4
DROP TABLE t1;

BUG#32198 "Comparison of DATE with DATETIME still not using indexes correctly"

CREATE TABLE t1 (
a varchar(32), index (a)
) DEFAULT CHARSET=latin1 COLLATE=latin1_bin;
INSERT INTO t1 VALUES
('B'), ('A'), ('A'), ('C'), ('B'), ('A'), ('A');
SELECT a FROM t1 WHERE a='b' OR a='B';
a
B
B
DROP TABLE t1;
CREATE TABLE t1 (f1 TINYINT(11) UNSIGNED NOT NULL, PRIMARY KEY (f1));
INSERT INTO t1 VALUES (127),(254),(0),(1),(255);
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 256;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 256.0;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 255;
COUNT(*)
4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < -1;
COUNT(*)
0
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -1;
COUNT(*)
5
DROP TABLE t1;
CREATE TABLE t1 ( f1 TINYINT(11) NOT NULL, PRIMARY KEY (f1));
INSERT INTO t1 VALUES (127),(126),(0),(-128),(-127);
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 128;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 128.0;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 127;
COUNT(*)
4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -129;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -129.0;
COUNT(*)
5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -128;
COUNT(*)
4
DROP TABLE t1;
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, b int, filler char(100));
insert into t2 select A.a + 10 * (B.a + 10 * C.a), 10, 'filler' from t1 A,
t1 B, t1 C where A.a < 5;
insert into t2 select 1000, b, 'filler' from t2;
alter table t2 add index (a,b);
select 'In following EXPLAIN the access method should be ref or range, #rows~=500 (and not 2)' Z;
Z
In following EXPLAIN the access method should be ref or range, #rows~=500 (and not 2)
drop table t1, t2;
CREATE TABLE t1( a INT, b INT, KEY( a, b ) );
CREATE TABLE t2( a INT, b INT, KEY( a, b ) );
CREATE TABLE t3( a INT, b INT, KEY( a, b ) );
INSERT INTO t1( a, b ) 
VALUES (0, 1), (1, 2), (1, 4), (2, 3), (5, 0), (9, 7);
INSERT INTO t2( a, b ) 
VALUES ( 1, 1), ( 2, 1), ( 3, 1), ( 4, 1), ( 5, 1),
( 6, 1), ( 7, 1), ( 8, 1), ( 9, 1), (10, 1), 
(11, 1), (12, 1), (13, 1), (14, 1), (15, 1),
(16, 1), (17, 1), (18, 1), (19, 1), (20, 1);
INSERT INTO t2 SELECT a, 2 FROM t2 WHERE b = 1;
INSERT INTO t2 SELECT a, 3 FROM t2 WHERE b = 1;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t3
VALUES (1, 0), (2, 0), (3, 0), (4, 0), (5, 0),
(6, 0), (7, 0), (8, 0), (9, 0), (10, 0);
INSERT INTO t3 SELECT * FROM t3 WHERE a = 10;
INSERT INTO t3 SELECT * FROM t3 WHERE a = 10;
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 <= a AND b = 3 OR
3 <= a;
a	b
5	0
9	7
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
3 <= a;
a	b
5	0
9	7
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 1 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;
a	b
1	1
2	1
3	1
4	1
5	1
6	1
7	1
8	1
9	1
10	1
11	1
12	1
13	1
14	1
15	1
15	3
16	1
16	3
17	1
17	3
18	1
18	3
19	1
19	3
20	1
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 2 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;
a	b
1	1
2	1
3	1
4	1
5	1
5	2
6	1
6	2
7	1
7	2
8	1
8	2
9	1
9	2
10	1
11	1
12	1
13	1
14	1
15	1
15	3
16	1
16	3
17	1
17	3
18	1
18	3
19	1
19	3
20	1
SELECT * FROM t3 WHERE
5 <= a AND a < 10 AND b = 3 OR 
a < 5 OR
a < 10;
a	b
1	0
2	0
3	0
4	0
5	0
6	0
7	0
8	0
9	0
DROP TABLE t1, t2, t3;
#
# Bug #47123: Endless 100% CPU loop with STRAIGHT_JOIN
#
CREATE TABLE t1(a INT, KEY(a));
INSERT INTO t1 VALUES (1), (NULL);
SELECT * FROM t1 WHERE a <> NULL and (a <> NULL or a <= NULL);
a
DROP TABLE t1;
#
# Bug#47925: regression of range optimizer and date comparison in 5.1.39!
#
CREATE TABLE t1 ( a DATE );
CREATE TABLE t2 ( a DATETIME );
# Make optimizer choose range scan
INSERT INTO t1 VALUES ('2009-09-22'), ('2009-09-22'), ('2009-09-22');
INSERT INTO t1 VALUES ('2009-09-23'), ('2009-09-23'), ('2009-09-23');
INSERT INTO t2 VALUES ('2009-09-22 12:00:00'), ('2009-09-22 12:00:00'),
('2009-09-22 12:00:00');
INSERT INTO t2 VALUES ('2009-09-23 12:00:00'), ('2009-09-23 12:00:00'),
('2009-09-23 12:00:00');
# DATE vs DATE
SELECT * FROM t1 WHERE a >= '2009/09/23';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '20090923';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >=  20090923;
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009-9-23';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009.09.23';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009:09:23';
a
2009-09-23
2009-09-23
2009-09-23
# DATE vs DATETIME
SELECT * FROM t2 WHERE a >= '2009/09/23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
Warnings:
Warning	1292	Truncated incorrect time value: '2009/09/23'
Warning	1292	Truncated incorrect time value: '2009/09/23'
SELECT * FROM t2 WHERE a >= '2009/09/23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
Warnings:
Warning	1292	Truncated incorrect time value: '2009/09/23'
Warning	1292	Truncated incorrect time value: '2009/09/23'
SELECT * FROM t2 WHERE a >= '20090923';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
Warnings:
Warning	1292	Truncated incorrect time value: '20090923'
Warning	1292	Truncated incorrect time value: '20090923'
SELECT * FROM t2 WHERE a >=  20090923;
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009-9-23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
Warnings:
Warning	1292	Truncated incorrect time value: '2009-9-23'
Warning	1292	Truncated incorrect time value: '2009-9-23'
SELECT * FROM t2 WHERE a >= '2009.09.23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
Warnings:
Warning	1292	Truncated incorrect time value: '2009.09.23'
Warning	1292	Truncated incorrect time value: '2009.09.23'
SELECT * FROM t2 WHERE a >= '2009:09:23';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
Warnings:
Warning	1292	Truncated incorrect time value: '2009:09:23'
Warning	1292	Truncated incorrect time value: '2009:09:23'
# DATETIME vs DATETIME
SELECT * FROM t2 WHERE a >= '2009/09/23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '20090923120000';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >=  20090923120000;
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009-9-23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009.09.23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
SELECT * FROM t2 WHERE a >= '2009:09:23 12:00:00';
a
2009-09-23 12:00:00
2009-09-23 12:00:00
2009-09-23 12:00:00
# DATETIME vs DATE
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '20090923000000';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >=  20090923000000;
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009-9-23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009.09.23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
SELECT * FROM t1 WHERE a >= '2009:09:23 00:00:00';
a
2009-09-23
2009-09-23
2009-09-23
# Test of the new get_date_from_str implementation
# Behavior differs slightly between the trunk and mysql-pe.
# The former may give errors for the truncated values, while the latter
# gives warnings. The purpose of this test is not to interfere, and only
# preserve existing behavior.
SELECT str_to_date('2007-10-00', '%Y-%m-%d') >= '' AND 
str_to_date('2007-10-00', '%Y-%m-%d') <= '2007/10/20';
str_to_date('2007-10-00', '%Y-%m-%d') >= '' AND 
str_to_date('2007-10-00', '%Y-%m-%d') <= '2007/10/20'
1
Warnings:
Warning	1292	Truncated incorrect date value: ''
SELECT str_to_date('2007-20-00', '%Y-%m-%d') >= '2007/10/20' AND 
str_to_date('2007-20-00', '%Y-%m-%d') <= '';
str_to_date('2007-20-00', '%Y-%m-%d') >= '2007/10/20' AND 
str_to_date('2007-20-00', '%Y-%m-%d') <= ''
NULL
Warnings:
Warning	1292	Truncated incorrect date value: ''
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
SELECT str_to_date('2007-10-00', '%Y-%m-%d') BETWEEN '' AND '2007/10/20';
str_to_date('2007-10-00', '%Y-%m-%d') BETWEEN '' AND '2007/10/20'
1
Warnings:
Warning	1292	Truncated incorrect datetime value: ''
SELECT str_to_date('2007-20-00', '%Y-%m-%d') BETWEEN '2007/10/20' AND '';
str_to_date('2007-20-00', '%Y-%m-%d') BETWEEN '2007/10/20' AND ''
NULL
Warnings:
Warning	1411	Incorrect datetime value: '2007-20-00' for function str_to_date
SELECT str_to_date('', '%Y-%m-%d');
str_to_date('', '%Y-%m-%d')
0000-00-00
DROP TABLE t1, t2;
#
# Bug#48459: valgrind errors with query using 'Range checked for each 
# record'
#
CREATE TABLE t1 (
a INT,
b CHAR(2),
c INT,
d INT,
KEY ( c ),
KEY ( d, a, b ( 2 ) ),
KEY ( b ( 1 ) )
);
INSERT INTO t1 VALUES ( NULL, 'a', 1, 2 ), ( NULL, 'a', 1, 2 ),
( 1,    'a', 1, 2 ), ( 1,    'a', 1, 2 );
CREATE TABLE t2 (
a INT,
c INT,
e INT,
KEY ( e )
);
INSERT INTO t2 VALUES ( 1, 1, NULL ), ( 1, 1, NULL );
# Should not give Valgrind warnings
SELECT 1
FROM t1, t2
WHERE t1.d <> '1' AND t1.b > '1'
AND t1.a = t2.a AND t1.c = t2.c;
1
1
1
1
1
DROP TABLE t1, t2;
#
# Bug #48665: sql-bench's insert test fails due to wrong result
#
CREATE TABLE t1 (a INT, b INT, PRIMARY KEY (a));
INSERT INTO t1 VALUES (0,0), (1,1);
EXPLAIN 
SELECT * FROM t1 FORCE INDEX (PRIMARY) 
WHERE (a>=1 AND a<=2) OR (a>=4 AND a<=5) OR (a>=0 AND a <=10);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
@	@	@	NULL	range	@	@	@	@	@	100.00	@
Warnings:
@	@	@
# Should return 2 rows
SELECT * FROM t1 FORCE INDEX (PRIMARY) 
WHERE (a>=1 AND a<=2) OR (a>=4 AND a<=5) OR (a>=0 AND a <=10);
a	b
0	0
1	1
DROP TABLE t1;
#
# Bug #54802: 'NOT BETWEEN' evaluation is incorrect
#
CREATE TABLE t1 (c_key INT, c_notkey INT, KEY(c_key));
INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3);
SELECT * FROM t1 WHERE 2 NOT BETWEEN c_notkey AND c_key;
c_key	c_notkey
1	1
3	3
DROP TABLE t1;
#
# Bug #57030: 'BETWEEN' evaluation is incorrect
#
CREATE TABLE t1(pk INT PRIMARY KEY, i4 INT);
CREATE UNIQUE INDEX i4_uq ON t1(i4);
INSERT INTO t1 VALUES (1,10), (2,20), (3,30);
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 10;
pk	i4
1	10
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND i4;
pk	i4
1	10
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND i4;
pk	i4
1	10
2	20
3	30
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND 10;
pk	i4
1	10
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND 10;
pk	i4
1	10
2	20
3	30
SELECT * FROM t1 WHERE 10 BETWEEN 11 AND 11;
pk	i4
SELECT * FROM t1 WHERE 10 BETWEEN 100 AND 0;
pk	i4
SELECT * FROM t1 WHERE i4 BETWEEN 100 AND 0;
pk	i4
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 99999999999999999;
pk	i4
1	10
2	20
3	30
SELECT * FROM t1 WHERE i4 BETWEEN 999999999999999 AND 30;
pk	i4
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND '20';
pk	i4
1	10
2	20
SELECT * FROM t1, t1 as t2 WHERE t2.pk BETWEEN t1.i4 AND t1.i4;
pk	i4	pk	i4
SELECT * FROM t1, t1 as t2 WHERE t1.i4 BETWEEN t2.pk AND t2.pk;
pk	i4	pk	i4
DROP TABLE t1;
#
# BUG#13519696 - 62940: SELECT RESULTS VARY WITH VERSION AND
# WITH/WITHOUT INDEX RANGE SCAN
#
#
# BUG#13453382 - REGRESSION SINCE 5.1.39, RANGE OPTIMIZER WRONG
# RESULTS WITH DECIMAL CONVERSION
#
create table t1 (a int,b int,c int,primary key (a,c));
insert into t1 values (1,1,2),(1,1,3),(1,1,4);
select convert(3, signed integer) > 2.9;
convert(3, signed integer) > 2.9
1
select * from t1 force  index (primary) where a=1 and c>= 2.9;
a	b	c
1	1	3
1	1	4
select * from t1 ignore index (primary) where a=1 and c>= 2.9;
a	b	c
1	1	3
1	1	4
select * from t1 force  index (primary) where a=1 and c> 2.9;
a	b	c
1	1	3
1	1	4
select * from t1 ignore index (primary) where a=1 and c> 2.9;
a	b	c
1	1	3
1	1	4
drop table t1;
#
# BUG#13463488 - 63437: CHAR & BETWEEN WITH INDEX RETURNS WRONG
# RESULT AFTER MYSQL 5.1.
#
End of 5.1 tests
CREATE TABLE t1 (c1 DECIMAL(10,0));
INSERT INTO t1 VALUES (1),(2),(3);
SELECT c1 FROM t1 WHERE c1 >= 'A' GROUP BY 1;
c1
1
2
3
Warnings:
Warning	1292	Truncated incorrect DECIMAL value: 'A'
DROP TABLE t1;
create table t1 (a int,b int,key (b),key (a),key (b,a));
insert into t1(a,b) values (1,2),(3,4),(5,6),(7,8);
create table t2 (c int);
insert into t2(c) values (1),(5),(6),(7),(8);
select 1 from (select c from t1,t2 where b >= 1 and a <=> c group by 1 limit 1) as d1;
1
1
drop table t1, t2;
#
# Bug #26106: Wrong plan may be chosen when there are several possible
# range and ref accesses
#
# Note: The fix for this bug has been reverted. The code will no longer
# select the optimal plan for the two following test queries. This is
# not due to a bug but due to minor differences in range estimates
# produced by the storage engine.
CREATE TABLE t1( 
a INT,
b INT,
KEY k ( a ),
KEY l ( a, b )
);
INSERT INTO t1(a) VALUES (1);
INSERT INTO t1 
VALUES (2,3),(2,3),(2,3),(2,3),(2,3),(2,3),(2,3),(2,3),(2,3),(2,3);
INSERT INTO t1 SELECT 3, 4 FROM t1 WHERE a = 2 AND b = 3;
INSERT INTO t1 SELECT 4, 1 FROM t1 WHERE a = 2 AND b = 3;
INSERT INTO t1 VALUES (1, 2);
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
INSERT INTO t1 SELECT a, b FROM t1 WHERE a=1 AND b=2;
# This must use range over index l, not k.
# Update: Due to patch being reverted and minor differences in 
#         range estimates k is selected.
CREATE TABLE t2( 
a INT, 
b INT, 
c INT,
KEY k ( a ), 
KEY l ( a, b ),
KEY m ( b ), 
KEY n ( a, c )
);
INSERT INTO t2(a) VALUES (1);
INSERT INTO t2 
VALUES (2,3,3),(2,3,3),(2,3,3),(2,3,3),(2,3,3),
(2,3,3),(2,3,3),(2,3,3),(2,3,3),(2,3,3);
INSERT INTO t2 SELECT 3, 4, 4 FROM t2 WHERE a = 2 AND b = 3;
INSERT INTO t2 SELECT 4, 1, 1 FROM t2 WHERE a = 2 AND b = 3;
INSERT INTO t2 VALUES (1, 2, 2);
INSERT INTO t2 SELECT a, b, c FROM t2 WHERE a=1 AND b=2;
INSERT INTO t2 SELECT a, b, c FROM t2 WHERE a=1 AND b=2;
INSERT INTO t2 SELECT a, b, c FROM t2 WHERE a=1 AND b=2;
INSERT INTO t2 SELECT a, b, c FROM t2 WHERE a=1 AND b=2;
INSERT INTO t2 SELECT a, b, c FROM t2 WHERE a=1 AND b=2;
INSERT INTO t2 SELECT a, b, c FROM t2 WHERE a=1 AND b=2;
INSERT INTO t2 VALUES (1, 1, 2);
# This must use range over index l, not n.
# Update: Due to patch being reverted and minor differences in 
#         range estimates k is selected.
DROP TABLE t1, t2;
#
# BUG#11765831: 'RANGE ACCESS' MAY INCORRECTLY FILTER 
#               AWAY QUALIFYING ROWS
#
#
# BUG#12698916 - JOIN QUERY GIVES WRONG RESULT AT 2ND EXEC. OR
# AFTER FLUSH TABLES [-INT VS NULL]
#
CREATE TABLE t1 (col_int INT, pk INT) ENGINE=sequoiadb STATS_PERSISTENT=0;
INSERT INTO t1 VALUES (-100,1),(1,6);
CREATE TABLE t2 (
col_int_key INT,
col_varchar VARCHAR(100) NOT NULL DEFAULT "DEFAULT",
pk INT NOT NULL,
PRIMARY KEY (pk),
KEY (col_int_key)
) ENGINE=sequoiadb STATS_PERSISTENT=0;
INSERT INTO t2 VALUES
(1,"GOOD",1),(100,"",2),(200,"",3),(300,"",4),(400,"",5),(500,"",8);
SELECT t1.*,t2.* FROM t1 straight_join t2
ON t2.col_int_key = t1.col_int WHERE t2.pk < t1.pk;
col_int	pk	col_int_key	col_varchar	pk
1	6	1	GOOD	1
# need FLUSH so that sequoiadb statistics change and thus plan changes
FLUSH TABLES;
SELECT t1.*,t2.* FROM t1 straight_join t2
ON t2.col_int_key = t1.col_int WHERE t2.pk < t1.pk;
col_int	pk	col_int_key	col_varchar	pk
1	6	1	GOOD	1
DROP TABLE t1,t2;
#
# Bug#12694872 - 
# VALGRIND: 18,816 BYTES IN 196 BLOCKS ARE DEFINITELY LOST IN UNIQUE::GET
#
#
# BUG#12912171 - ASSERTION FAILED: QUICK->HEAD->READ_SET ==
# SAVE_READ_SET
#
#
# BUG#13256446 - ASSERTION QUICK->HEAD->READ_SET ==
# SAVE_READ_SET' FAILED IN OPT_RANGE.CC:1606 
#
#
# BUG#13731380: RANGE OPTIMIZER CALLS RECORDS_IN_RANGE() FOR OPEN RANGE
#
CREATE TABLE t1 (pk INT PRIMARY KEY);
INSERT INTO t1 VALUES (1),(3),(5);
SELECT * FROM t1 WHERE pk <> 3 OR pk < 4;
pk
1
3
5
DROP TABLE t1;
#
# BUG#13803810: TOO FEW ROWS RETURNED FOR RANGE ACCESS IN 
#               VARCHAR INDEX USING DATETIME VALUE

CREATE TABLE t1 (a DATETIME);
INSERT INTO t1 VALUES ('2001-01-01 00:00:00');
INSERT INTO t1 VALUES ('2001-01-01 11:22:33');
CREATE TABLE t2 (b VARCHAR(64), KEY (b));
INSERT INTO t2 VALUES ('2001-01-01');
INSERT INTO t2 VALUES ('2001.01.01');
INSERT INTO t2 VALUES ('2001#01#01');
INSERT INTO t2 VALUES ('2001-01-01 00:00:00');
INSERT INTO t2 VALUES ('2001-01-01 11:22:33');

# range/ref access cannot be used for this query


# range/ref access cannot be used for any of the queries below.
# See BUG#13814468 about 'Range checked for each record'

SELECT * FROM t1, t2 WHERE a=b ORDER BY BINARY a, BINARY b;
a	b
2001-01-01 00:00:00	2001#01#01
2001-01-01 00:00:00	2001-01-01
2001-01-01 00:00:00	2001-01-01 00:00:00
2001-01-01 00:00:00	2001.01.01
2001-01-01 11:22:33	2001-01-01 11:22:33

SELECT * FROM t1, t2 WHERE b=a ORDER BY BINARY a, BINARY b;
a	b
2001-01-01 00:00:00	2001#01#01
2001-01-01 00:00:00	2001-01-01
2001-01-01 00:00:00	2001-01-01 00:00:00
2001-01-01 00:00:00	2001.01.01
2001-01-01 11:22:33	2001-01-01 11:22:33

DROP TABLE t1,t2;
#
# WL#7019: Add support for row value constructors in in predicates to
# range optimizer
#
#
# Bug#17635476: CRASH IN GET_MM_PARTS() OR ASSERT IN
# GET_FUNC_MM_TREE_FROM_IN_PREDICATE()
#
CREATE TABLE t1 (
a INT,
b INT,
KEY (a)
) ENGINE = sequoiadb;
SELECT DISTINCT a FROM t1 WHERE (a, b) IN ((0, 0), (1, 1));
a
DROP TABLE t1;
#
# Bug#17755540 VALGRIND ERROR WHEN SETTING UP ROW COMPARATORS
#
CREATE TABLE t2 (a INT, b INT, c INT, d INT, KEY x(a, b));
INSERT INTO t2 VALUES (2, 2, 2, 2), (3, 3, 3, 3), (4, 4, 4, 4), (5, 5, 5, 5),
(6, 6, 6, 6), (7, 7, 7, 7), (8, 8, 8, 8), (9, 9, 9, 9);
INSERT INTO t2 SELECT * FROM t2;
INSERT INTO t2 VALUES (0, 0, 0, 0), (1, 1, 1, 1);
SELECT a, b FROM t2 WHERE (a, b) IN ((0, 0), (1, 1));
a	b
0	0
1	1
DROP TABLE t2;
#
# BUG#18364815: OPTIMIZER PREFERS TABLE SCAN WHEN 
#               USING "IN" WITH VALUE OF DIFFERENT TYPE
#
CREATE TABLE t1 (a INT PRIMARY KEY, b INT);
INSERT INTO t1 VALUES (1,1), (2,1), (3,1), (4,1), (5,1), (6,1);
SELECT * FROM t1 WHERE a IN (1, 2);
a	b
1	1
2	1
SELECT * FROM t1 WHERE a IN (1, "2");
a	b
1	1
2	1
DROP TABLE t1;
# 
# Bug#18715670
# CRASH IN DECIMAL_ACTUAL_FRACTION COMPARING DECIMAL TO NULLS
# 
CREATE TABLE t1(n DECIMAL(39,19) NOT NULL) engine=sequoiadb;
INSERT INTO t1 SET n=0;
SELECT 1 FROM t1 WHERE n NOT IN(NULL, NULL);
1
DROP TABLE t1;
#
# Bug#18759597 MISSING ROWS ON WHERE .. 
#              IN QUERY WITH VARIABLES AND CONCAT
#
CREATE TABLE t1 (
col_varchar_key varchar(2),
KEY col_varchar_key (col_varchar_key)
) ENGINE=sequoiadb;
INSERT INTO t1 VALUES ('n'),('xm');
SET @var1 = 't', @var2 = 'him',
@var3 = 'n', @var4 = 'n',
@var5 = 'n', @var6 = 'g',
@var7 = 'b', @var8 = 'o',
@var9 = 'm', @var10 = 'xm', @var11 = 'u'
;
SELECT col_varchar_key AS field1
FROM t1
WHERE ( col_varchar_key, col_varchar_key ) IN (
('m', @var1  ),
('n', @var3  ),
('a', @var5  ),
('l', @var7  ),
(CONCAT('x', @var9 ), @var10 )
);
field1
n
xm
DROP TABLE t1;
#
# Bug#18535226 	DEBUG CRASH ON QUICK_RANGE_SELECT::RESET
#
SET @old_tmp_table_size=@@tmp_table_size;
SET tmp_table_size=1024;
CREATE TABLE t1 (
pk INT NOT NULL,
col_int_key INT,
col_date_key date,
col_date_nokey date,
col_time_key time,
col_time_nokey time,
col_datetime_key datetime,
col_datetime_nokey datetime,
col_varchar_key varchar(1),
col_varchar_nokey varchar(1),
PRIMARY KEY (pk),
KEY col_int_key (col_int_key)
) ENGINE=sequoiadb;
INSERT INTO t1 VALUES
(5,0,'2001-05-06','2001-05-06','16:21:18','16:21:18','2001-11-08 21:02:12',
'2001-11-08 21:02:12','x','x'),(6,7,'2006-03-03','2006-03-03','18:56:33',
'18:56:33','2003-04-01 00:00:00','2003-04-01 00:00:00','i','i'),
(7,7,'2007-12-28','2007-12-28',NULL,NULL,'1900-01-01 00:00:00',
'1900-01-01 00:00:00','e','e'),(8,1,'2004-10-20','2004-10-20','09:29:08',
'09:29:08','2007-07-12 00:00:00','2007-07-12 00:00:00','p','p'),
(9,7,'2008-04-09','2008-04-09','19:11:10','19:11:10',
'2005-04-04 01:21:01','2005-04-04 01:21:01','s','s'),
(10,1,'2005-12-25','2005-12-25','11:57:26','11:57:26',
'1900-01-01 00:00:00','1900-01-01 00:00:00','j','j');
SELECT alias1.col_int_key
FROM
( SELECT SQ1_alias1.* FROM t1 AS SQ1_alias1, t1 AS SQ1_alias2 ) AS alias1,
(SELECT 7 AS col_int_nokey) AS alias2
WHERE
alias2.col_int_nokey = alias1.pk
AND alias1.col_varchar_nokey < alias1.col_varchar_key
ORDER BY alias1.col_varchar_key;
col_int_key
DROP TABLE t1;
SET tmp_table_size=@old_tmp_table_size;
SET sql_mode = default;
#
# Bug#19585938 Crash in get_full_func_mm_tree with null
#              item_field->table_ref
#
CREATE TABLE t1(id INTEGER, col1 INTEGER, col2 INTEGER, PRIMARY KEY(id));
INSERT INTO t1 VALUES (1,2,3), (3,2,1);
SELECT (SELECT 1
FROM t1
WHERE SUM(1) < id
) AS c
FROM t1
GROUP BY col1;
c
1
SELECT (SELECT 1
FROM t1
WHERE id > SUM(1)
) AS c
FROM t1
GROUP BY col1;
c
1
SELECT (SELECT 1
FROM t1
WHERE SUM(1) BETWEEN id AND id+1
) AS c
FROM t1
GROUP BY col1;
c
1
SELECT (SELECT 1
FROM t1
WHERE id BETWEEN SUM(1) AND SUM(5)
) AS c
FROM t1
GROUP BY col1;
c
1
SELECT (SELECT 1
FROM t1
WHERE SUM(1) BETWEEN COUNT(*) AND id
) AS c
FROM t1
GROUP BY col1;
c
1
DROP TABLE t1;
#
# Bug#21415791 VALGRIND ERROR (CONDITIONAL JUMP) AT KEY_AND
#              (RANGE_OPT_PARAM*, SEL_ARG*, SEL_AR
#
CREATE TABLE t1 (
col_varchar_10 VARCHAR(10),
pk INTEGER NOT NULL,
col_int_key INTEGER,
PRIMARY KEY (pk),
KEY col_int_key (col_int_key),
KEY col_varchar_10 (col_varchar_10)
) ENGINE=sequoiadb;
INSERT INTO t1 (
pk, col_varchar_10, col_int_key) VALUES
(1, 'ttttt', 0), (2, 'zzzzz', 0), (3, 'ggggg', 0),
(4, 'hhhhh', 0), (5, 'kkkkk', 0), (6, 'lllll', 0);
CREATE TABLE t2 (
pk INTEGER NOT NULL,
col_varchar_10 VARCHAR(10),
PRIMARY KEY (pk),
KEY col_varchar_10 (col_varchar_10)
) ENGINE=sequoiadb;
INSERT INTO t2 (
pk,  col_varchar_10) VALUES
(1, '00000'), (2, '00000'), (3, '44444'), (4, '00000'),
(5, NULL), (6, NULL), (7, NULL);
SELECT COUNT(t1.col_int_key)
FROM t2 RIGHT OUTER JOIN t1 ON t2.col_varchar_10 <= t1.col_varchar_10
WHERE t2.pk <> 4 OR t2.pk != t1.col_int_key AND t2.pk <> 1000;
COUNT(t1.col_int_key)
24
DROP TABLE t1, t2;
#
# Bug #20229614: OR CONDITIONS ON MULTI-COLUMN INDEX MAY NOT USE ALL
#                INDEX COLUMNS TO FILTER ROWS
#
CREATE TABLE t1 (
c1 INT,
c2 INT,
c3 INT,
PRIMARY KEY(c1, c2, c3)
) ENGINE=sequoiadb;
INSERT INTO t1 VALUES (1, 1, 1), (1, 1, 2), (1, 1, 3),
(1, 1, 4), (1, 1, 5);
INSERT INTO t1 SELECT c1, 2, c3 FROM t1;
INSERT INTO t1 SELECT c1, 3, c3 FROM t1 WHERE c2 = 1;
SELECT COUNT(*) FROM t1;
COUNT(*)
15
DROP TABLE t1;
#
# Bug#21139683: ASSERTION FAILED: TYPE_ARG == MAYBE_KEY ||
#               TYPE_ARG == IMPOSSIBLE
#
#
# Bug#19333852: RESULT DIFF IN QUERY HAVING DISTINCT
#               WITH GROUP BY
#
#
# Bug #21761867: ASSERTION `TYPE_ARG == MAYBE_KEY ||
#                TYPE_ARG == IMPOSSIBLE' FAILED.
#
CREATE TABLE t1 (
c10 INT NOT NULL,
c12 INT NOT NULL,
c18 INT,
PRIMARY KEY (c10,c12),
UNIQUE KEY key_c12(c12),
KEY key_c18(c18));
INSERT INTO t1 VALUES(11,5,0), (12,6,1), (13,7,2), (14,8,3), (15,9,4);
CREATE TABLE t2 (
c10 INT NOT NULL,
c12 INT NOT NULL,
PRIMARY KEY(c10,c12));
CREATE TABLE t3 (c10 INT NOT NULL);
SELECT t2.c10
FROM t1
RIGHT JOIN t3
LEFT JOIN t2
ON t3.c10 = t2.c10
ON t1.c12 > t2.c12
WHERE
t1.c10 <= 25
AND
t1.c18 IS NOT NULL
OR
t1.c10 > 5
AND
t1.c18 IN (15,16,18);
c10
DROP TABLE t1, t2, t3;
#
# Bug #21318711: WRONG RESULTS FOR TRUNCATED COLUMN AND AGGREGATION
#
CREATE TABLE t1 (
col1 VARCHAR(5),
col2 INT NOT NULL,
PRIMARY KEY (col1, col2)
) ENGINE=sequoiadb;
INSERT INTO t1 VALUES ('abcde', 10);
SELECT MAX(col2) FROM t1 WHERE col1 = 'abcdeaa';
MAX(col2)
NULL
SELECT MAX(col2) FROM t1 WHERE col1 = 'abcde  ';
MAX(col2)
10
DROP TABLE t1;
#
# Bug# 22283790: RANGE OPTIMIZER UTILIZES TOO MUCH MEMORY WITH
#                MANY OR CONDITIONS
#
#
# Bug #23259872: OPTIMIZER CHOOSES TO USE NON PRIMARY
#                INDEX, EVEN THOUGH COST IS HIGHER
#
set optimizer_switch=default;
